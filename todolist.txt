# Haskell

===============================
    ____        __             
   /  _/____   / /_ _____ ____ 
   / / / __ \ / __// ___// __ \
 _/ / / / / // /_ / /   / /_/ /
/___//_/ /_/ \__//_/    \____/ 

===============================

The task is basically using provided parsers to construct customized parsers and finish parsing

Parsers can parse specific Char or String and return it’s value

Known basic parser list (with examples):
01. string “False”		parse “False”			return “False”
02. char ‘,’ 			parse ‘,’			return ‘,’
03. digit			parse 0-9			return ‘0’-‘9’

To compile & run the code, using:
01. stack build
02. stack exec final-exe

To debug the code, using:
01. stack ghci

To combine parsers:
01. many / many1		duplicate
02. lexeme $ 			remove space after
03. <|>				or
04. <+>				a->a->[a], multi
05. <++>			[a]->[a]->[a], concat
06. <:>				a->[a]->[a], concat
07. <?>
08. <*>
09. *>				a->b->b
10. <*				a->b->a

01.
http://research.microsoft.com/en-us/um/people/daan/download/parsec/parsec.pdf

02.
http://dev.stephendiehl.com/fun/002_parsers.html

03. Just look at this can finish the project
https://www.schoolofhaskell.com/school/starting-with-haskell/basics-of-haskell/4-symbolic-calculator-recursion

04. How to combine multi source file in stack
https://github.com/erikd/language-javascript/tree/new-ast/src/Language/JavaScript/Parser

=================================================
  ______              __          __ _        __ 
 /_  __/____     ____/ /____     / /(_)_____ / /_
  / /  / __ \   / __  // __ \   / // // ___// __/
 / /  / /_/ /  / /_/ // /_/ /  / // /(__  )/ /_  
/_/   \____/   \__,_/ \____/  /_//_//____/ \__/  
                                                 
=================================================

01. [done] divide by modules
02. [done] replace Either Double Bool with something else, e.g. data d = x | y | z
03. [done] remove all left and right (with bool and double) in either expressions
04. [done] String implementation wrong
05. [done] reduce ‘(‘ -> “something” -> xxx -> ‘)’, e.g. specify Expr num
06. refine print (show functionalities)
07. add For statement
08. robustic REPL
09. accuracy error detection
10. pretty REPL
11. modify variable name to Text
12. fix variable name

====================================================
    ______              __                          
   / ____/___   ____ _ / /_ __  __ _____ ___   _____
  / /_   / _ \ / __ `// __// / / // ___// _ \ / ___/
 / __/  /  __// /_/ // /_ / /_/ // /   /  __/(__  ) 
/_/     \___/ \__,_/ \__/ \__,_//_/    \___//____/  

====================================================

01. arrange source files by modules
02. using combinators as many as possible (parser combinators)
03. Monad style
04. exploit symbols that can simplify expressions
05. add Show statement to REPL
06. lazy evaluation for nest function call


====================================================
    ______                                __    
   / ____/_  __ ____ _ ____ ___   ____   / /___ 
  / __/  | |/_// __ `// __ `__ \ / __ \ / // _ \
 / /___ _>  < / /_/ // / / / / // /_/ // //  __/
/_____//_/|_| \__,_//_/ /_/ /_// .___//_/ \___/ 
                              /_/               
====================================================

01.
(+ 1 2.2)

02.
(begin 
	(set! abc 1.2)
	(set! def 3.2)
	(set! aaa (+ abc def))
)

03.
(begin (set! i 1) (set! sum 0) (while (<= i 10) (begin (set! sum (+ sum i )) (set! i (+ i 1)))))
(begin
	(set! i 1)
	(set! sum 0)
	(while (<= i 10)
		(begin
			(set! sum (+ sum i))
			(set! i (+ i 1))
		)
	)
)

05.
(define (foo x ) (begin (set! y (* x 2)) (return (+ y 1))))

06.
(define (foo x) (if (> x 0) (begin (return (* x (foo (- x 1))))) (return 1)))