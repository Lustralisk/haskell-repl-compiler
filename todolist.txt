# Haskell

===============================
    ____        __
   /  _/____   / /_ _____ ____
   / / / __ \ / __// ___// __ \
 _/ / / / / // /_ / /   / /_/ /
/___//_/ /_/ \__//_/    \____/

===============================

The task is basically using provided parsers to construct customized parsers and finish parsing

Parsers can parse specific Char or String and return it’s value

Known basic parser list (with examples):
01. string “False”		parse “False”			return “False”
02. char ‘,’ 			parse ‘,’			return ‘,’
03. digit			parse 0-9			return ‘0’-‘9’

To compile & run the code, using:
01. stack build
02. stack exec final-exe

To debug the code, using:
01. stack ghci

To combine parsers:
01. many / many1		duplicate
02. lexeme $ 			remove space after
03. <|>				or
04. <+>				a->a->[a], multi
05. <++>			[a]->[a]->[a], concat
06. <:>				a->[a]->[a], concat
07. <?>
08. <*>
09. *>				a->b->b
10. <*				a->b->a

01.
http://research.microsoft.com/en-us/um/people/daan/download/parsec/parsec.pdf

02.
http://dev.stephendiehl.com/fun/002_parsers.html

03. Just look at this can finish the project
https://www.schoolofhaskell.com/school/starting-with-haskell/basics-of-haskell/4-symbolic-calculator-recursion

04. How to combine multi source file in stack
https://github.com/erikd/language-javascript/tree/new-ast/src/Language/JavaScript/Parser

05. State Monad Transformer
http://catamorph.de/documents/Transformers.pdf

=================================================
  ______              __          __ _        __
 /_  __/____     ____/ /____     / /(_)_____ / /_
  / /  / __ \   / __  // __ \   / // // ___// __/
 / /  / /_/ /  / /_/ // /_/ /  / // /(__  )/ /_
/_/   \____/   \__,_/ \____/  /_//_//____/ \__/

=================================================

01. [done] divide by modules
02. [done] replace Either Double Bool with something else, e.g. data d = x | y | z
03. [done] remove all left and right (with bool and double) in either expressions
04. [done] String implementation wrong
05. [done] reduce ‘(‘ -> “something” -> xxx -> ‘)’, e.g. specify Expr num
06. [done] refine print (show functionalities)
07. add For statement
08. robustic REPL
09. [done] accuracy error detection
10. pretty REPL
11. [done] modify variable name to Text
12. fix variable name
13. [done] finish lambda expression
14. reduce (hist ++ " " ++ line) expression
15. [done] check elem's type, namely construct function, in ListValue

====================================================
    ______              __
   / ____/___   ____ _ / /_ __  __ _____ ___   _____
  / /_   / _ \ / __ `// __// / / // ___// _ \ / ___/
 / __/  /  __// /_/ // /_ / /_/ // /   /  __/(__  )
/_/     \___/ \__,_/ \__/ \__,_//_/    \___//____/

====================================================

01. arrange source files by modules
02. using combinators as many as possible (parser combinators)
03. Monad style
04. exploit symbols that can simplify expressions
05. add pretty statement to REPL
06. lazy evaluation for nested function call
07. smart REPL
08. GNU emacs coding style for printer
09. use Monad, Monad Transformer

====================================================
    ______                                __
   / ____/_  __ ____ _ ____ ___   ____   / /___
  / __/  | |/_// __ `// __ `__ \ / __ \ / // _ \
 / /___ _>  < / /_/ // / / / / // /_/ // //  __/
/_____//_/|_| \__,_//_/ /_/ /_// .___//_/ \___/
                              /_/
====================================================

00.
$ stack ghci
>>> import qualified Data.Map as M
>>> env = M.empty
>>> evalExpr env "(+ 1 3)"
DoubleValue 4.0
>>> env' = evalStatement env "(set! x 1)"
>>> env'
fromList [("x",DoubleValue 1.0)]
>>> evalExpr env' "x"
DoubleValue 1.0
>>> env'' = evalFunction env' "(define (foo x) (if (> x 0) (begin (return (* x (foo (- x 1))))) (return 1)))"
>>> evalExpr env'' "(foo 4)"
DoubleValue 24.0

>>> import Control.Applicative
>>> import Control.Monad
>>> import Data.Functor
>>> import Data.Text
>>> import Data.Attoparsec.Text
>>> parseOnly exprParser $ pack "(+ 1 2)"
Right (Add (Number 1.0) (Number 2.0))
>>> parseOnly functionParser $ pack "(define (foo x) (if (> x 0) (begin (return (* x (foo (- x 1))))) (return 1)))"
Right (Def "foo" ["x"] (If (Gr (Variable "x") (Number 0.0)) (StatementList [Return (Mul (Variable "x") (Function "foo" [Sub (Variable "x") (Number 1.0)]))]) (Return (Number 1.0))))
>>> parseOnly exprParser $ pack "(+ 1 True)"
Right (Add (Number 1.0) TrueLit) 				-- error case
>>> parseOnly exprParser $ pack "(+ 1 2.)"
Left "Failed reading: empty" 					-- parseOnly error report

01.
(+ 1 2.2)

02.
(begin
	(set! abc 1.2)
	(set! def 3.2)
	(set! aaa (+ abc def))
)

03.
(begin (set! i 1) (set! sum 0) (while (<= i 10) (begin (set! sum (+ sum i )) (set! i (+ i 1)))))
(begin
	(set! i 1)
	(set! sum 0)
	(while (<= i 10)
		(begin
			(set! sum (+ sum i))
			(set! i (+ i 1))
		)
	)
)

05.
(define (foo x ) (begin (set! y (* x 2)) (return (+ y 1))))

06.
(define (foo x) (if (> x 0) (begin (return (* x (foo (- x 1))))) (return 1)))
